<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¯ä»¶æ‰«æä¸“ä¸šç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        /* === åŸºç¡€è®¾ç½® === */
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
        body { 
            background: #f0f2f5; 
            font-family: -apple-system, sans-serif; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; padding-bottom: 90px;
            overflow-x: hidden;
        }

        /* === A4 çº¸å¼ å®¹å™¨ === */
        .paper-container {
            background: white; 
            width: 95vw; max-width: 500px; aspect-ratio: 210/297; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.15); 
            border-radius: 4px;
            display: flex; flex-direction: column; 
            justify-content: center; align-items: center; 
            gap: 40px; padding: 0;
            position: relative;
        }

        /* === æ‰«æå¡æ§½ (ç»å¯¹å±…ä¸­) === */
        .scan-slot {
            width: 85.6mm; height: 54mm; 
            max-width: 85%; aspect-ratio: 85.6/54; 
            border: 2px dashed #9ca3af; 
            background-color: #f8fafc; 
            border-radius: 8px; 
            position: relative; 
            overflow: hidden; 
            cursor: pointer; 
            display: flex; justify-content: center; align-items: center;
        }

        /* å›¾ç‰‡å¼ºåˆ¶ç»å¯¹å±…ä¸­ï¼Œç¡®ä¿ä¸åå·¦ */
        .scan-slot img { 
            position: absolute; 
            top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            width: 100%; height: 100%; 
            object-fit: fill; 
            display: none; z-index: 10;
        }

        .slot-placeholder { text-align: center; color: #94a3b8; pointer-events: none; z-index: 1; }
        .slot-placeholder h3 { font-size: 16px; margin-bottom: 5px; color: #475569; }

        /* === åº•éƒ¨ä¸»æŒ‰é’® === */
        .bottom-bar {
            position: fixed; bottom: 0; left: 0; width: 100%; 
            background: white; padding: 15px 20px;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.05); 
            display: flex; gap: 15px; z-index: 100;
        }
        .btn { flex: 1; height: 50px; border-radius: 25px; border: none; font-size: 16px; font-weight: bold; cursor: pointer; }
        .btn-main { background: #2563eb; color: white; }
        .btn-sec { background: #f1f5f9; color: #334155; }

        /* === å…¨å± Canvas ç›¸æœº === */
        .camera-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999; 
            display: none; 
        }

        /* æ¸²æŸ“ç”»å¸ƒ */
        canvas#camera-canvas {
            display: block; width: 100%; height: 100%;
        }

        /* éšè—çš„ video */
        #hidden-video { display: none; }

        /* ç•Œé¢æ§ä»¶å±‚ */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; 
            display: flex; flex-direction: column; justify-content: space-between; align-items: center;
            padding: 40px 0;
            z-index: 20;
        }

        .top-tip {
            color: white; background: rgba(0,0,0,0.5); 
            padding: 8px 16px; border-radius: 20px; font-size: 14px;
            text-shadow: 0 1px 2px black; margin-top: 20px;
        }

        .controls-area {
            width: 100%; pointer-events: auto;
            display: flex; flex-direction: column; align-items: center; gap: 25px;
            padding-bottom: 30px;
        }

        /* æ¨¡å¼åˆ‡æ¢æŒ‰é’® */
        .mode-btn {
            background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.5);
            color: #4ade80; padding: 10px 24px; border-radius: 30px; 
            font-size: 14px; cursor: pointer; backdrop-filter: blur(4px);
            transition: all 0.3s;
        }

        .shutter-row {
            display: flex; width: 100%; justify-content: space-around; align-items: center;
        }

        .shutter-btn { 
            width: 72px; height: 72px; background: white; border-radius: 50%; 
            border: 4px solid rgba(255,255,255,0.8); cursor: pointer; 
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            transition: transform 0.1s;
        }
        .shutter-btn:active { transform: scale(0.9); background: #eee; }

        .circle-btn {
            width: 48px; height: 48px; border-radius: 50%;
            background: rgba(255,255,255,0.2); backdrop-filter: blur(4px);
            border: none; color: white; font-size: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer;
        }
        
        .generating .scan-slot { border: none; background: white; }
        .generating .slot-placeholder { display: none; }
    </style>
</head>
<body>

    <div class="paper-container" id="pdf-area">
        <div class="scan-slot" onclick="startCamera('front')">
            <div class="slot-placeholder" id="ph-front">
                <span style="font-size:24px">ğŸ“·</span>
                <h3>æ‹æ‘„äººåƒé¢</h3><p>ç‚¹å‡»å¼€å¯ç›¸æœº</p>
            </div>
            <img id="img-front">
        </div>
        <div class="scan-slot" onclick="startCamera('back')">
            <div class="slot-placeholder" id="ph-back">
                <span style="font-size:24px">ğŸ“·</span>
                <h3>æ‹æ‘„å›½å¾½é¢</h3><p>ç‚¹å‡»å¼€å¯ç›¸æœº</p>
            </div>
            <img id="img-back">
        </div>
    </div>

    <div class="bottom-bar">
        <button class="btn btn-sec" onclick="location.reload()">æ¸…ç©º</button>
        <button class="btn btn-main" onclick="makePDF()">ç”Ÿæˆ PDF</button>
    </div>

    <div class="camera-overlay" id="cam-modal">
        <video id="hidden-video" autoplay playsinline muted></video>
        <canvas id="camera-canvas"></canvas>

        <div class="ui-layer">
            <div class="top-tip">å°†è¯ä»¶æ”¾å…¥æ¡†å†…ï¼Œè‡ªåŠ¨å±…ä¸­è£å‰ª</div>
            
            <div class="controls-area">
                <button class="mode-btn" id="color-btn" onclick="toggleColor()">ğŸ¨ å½“å‰ï¼šå½©è‰²åŸå›¾</button>

                <div class="shutter-row">
                    <button class="circle-btn" onclick="closeCamera()">å–æ¶ˆ</button>
                    <button class="shutter-btn" onclick="takePhoto()"></button>
                    <button class="circle-btn" onclick="switchCamera()">åˆ‡æ¢</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let stream = null;
        let animationId = null;
        let currentSide = '';
        let isColor = true; // é»˜è®¤å½©è‰²
        let devices = [];
        let devIdx = 0;

        const video = document.getElementById('hidden-video');
        const canvas = document.getElementById('camera-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const modal = document.getElementById('cam-modal');
        const colorBtn = document.getElementById('color-btn');

        // 1. é¢œè‰²åˆ‡æ¢
        function toggleColor() {
            isColor = !isColor;
            if (isColor) {
                colorBtn.innerText = "ğŸ¨ å½“å‰ï¼šå½©è‰²åŸå›¾";
                colorBtn.style.color = "#4ade80";
                colorBtn.style.borderColor = "rgba(74, 222, 128, 0.5)";
            } else {
                colorBtn.innerText = "ğŸ“„ å½“å‰ï¼šé»‘ç™½å¤å°";
                colorBtn.style.color = "white";
                colorBtn.style.borderColor = "rgba(255,255,255,0.5)";
            }
        }

        // 2. å¯åŠ¨ç›¸æœº
        async function startCamera(side) {
            currentSide = side;
            modal.style.display = 'block';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            try {
                // ä¼˜å…ˆè¯·æ±‚é«˜æ¸…åç½®
                await startStream({ video: { facingMode: "environment", width: { ideal: 1920 }, height: { ideal: 1080 } } });
            } catch (e) {
                await startStream({ video: true }); // é™çº§
            }
            
            await listDevices();
            drawLoop(); // å¯åŠ¨æ¸²æŸ“å¾ªç¯
        }

        async function startStream(constraints) {
            if (stream) stream.getTracks().forEach(t => t.stop());
            try {
                stream = await navigator.mediaDevices.getUserMedia({ audio: false, ...constraints });
                video.srcObject = stream;
                await video.play();
            } catch (e) {
                alert("ç›¸æœºå¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥HTTPSå’Œæƒé™: " + e.message);
            }
        }

        async function listDevices() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return;
            const devs = await navigator.mediaDevices.enumerateDevices();
            devices = devs.filter(d => d.kind === 'videoinput');
        }

        async function switchCamera() {
            if (devices.length < 2) { await listDevices(); if(devices.length<2) return; }
            devIdx = (devIdx + 1) % devices.length;
            await startStream({ video: { deviceId: { exact: devices[devIdx].deviceId } } });
        }

        // 3. æ ¸å¿ƒï¼šä¸“ä¸šå–æ™¯æ¡†ç»˜åˆ¶
        function drawLoop() {
            if (modal.style.display === 'none') return;
            
            const cW = canvas.width;
            const cH = canvas.height;
            ctx.clearRect(0, 0, cW, cH);

            const vW = video.videoWidth;
            const vH = video.videoHeight;
            
            // ç»˜åˆ¶åº•å±‚è§†é¢‘
            if (vW && vH) {
                const scale = Math.max(cW / vW, cH / vH);
                const drawW = vW * scale;
                const drawH = vH * scale;
                const offsetX = (cW - drawW) / 2;
                const offsetY = (cH - drawH) / 2;
                ctx.drawImage(video, offsetX, offsetY, drawW, drawH);
            }

            // è®¡ç®—å–æ™¯æ¡†ä½ç½® (æ ‡å‡†èº«ä»½è¯æ¯”ä¾‹)
            const boxW = cW * 0.85; 
            const boxH = boxW / 1.585; 
            const boxX = (cW - boxW) / 2;
            const boxY = (cH - boxH) / 2 - 40;

            // === ç»˜åˆ¶é»‘è‰²é®ç½© (æ›´æ·±è‰² 0.85) ===
            ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
            ctx.fillRect(0, 0, cW, cH);

            // === æŒ–ç©ºä¸­é—´ (è®©è§†é¢‘äº®èµ·æ¥) ===
            ctx.clearRect(boxX, boxY, boxW, boxH);
            
            // ä¸ºäº†ä¿è¯æŒ–ç©ºåŒºåŸŸæœ‰ç”»é¢ï¼Œéœ€è¦å†ç”»ä¸€æ¬¡è§†é¢‘ï¼Œå¹¶è£å‰ª
            ctx.save();
            ctx.beginPath();
            ctx.rect(boxX, boxY, boxW, boxH);
            ctx.clip();
            if (vW && vH) {
                const scale = Math.max(cW / vW, cH / vH);
                const drawW = vW * scale;
                const drawH = vH * scale;
                const offsetX = (cW - drawW) / 2;
                const offsetY = (cH - drawH) / 2;
                ctx.drawImage(video, offsetX, offsetY, drawW, drawH);
            }
            ctx.restore();

            // === ç»˜åˆ¶ä¸“ä¸šå–æ™¯æ¡† (å››è§’) ===
            const lineLen = 20; // è§’çº¿é•¿åº¦
            ctx.lineWidth = 4;
            ctx.strokeStyle = "#00ff00";
            ctx.lineCap = "round";

            ctx.beginPath();
            // å·¦ä¸Šè§’
            ctx.moveTo(boxX, boxY + lineLen); ctx.lineTo(boxX, boxY); ctx.lineTo(boxX + lineLen, boxY);
            // å³ä¸Šè§’
            ctx.moveTo(boxX + boxW - lineLen, boxY); ctx.lineTo(boxX + boxW, boxY); ctx.lineTo(boxX + boxW, boxY + lineLen);
            // å³ä¸‹è§’
            ctx.moveTo(boxX + boxW, boxY + boxH - lineLen); ctx.lineTo(boxX + boxW, boxY + boxH); ctx.lineTo(boxX + boxW - lineLen, boxY + boxH);
            // å·¦ä¸‹è§’
            ctx.moveTo(boxX + lineLen, boxY + boxH); ctx.lineTo(boxX, boxY + boxH); ctx.lineTo(boxX, boxY + boxH - lineLen);
            ctx.stroke();

            // ç»˜åˆ¶ä¸­é—´çš„ç»†è™šçº¿æ¡† (è¾…åŠ©å¯¹é½)
            ctx.lineWidth = 1;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(boxX, boxY, boxW, boxH);
            ctx.setLineDash([]); // æ¢å¤å®çº¿

            animationId = requestAnimationFrame(drawLoop);
        }

        // 4. æ‹ç…§ä¸è£å‰ª
        function takePhoto() {
            cancelAnimationFrame(animationId);

            const cW = canvas.width;
            const cH = canvas.height;
            const boxW = cW * 0.85;
            const boxH = boxW / 1.585;
            const boxX = (cW - boxW) / 2;
            const boxY = (cH - boxH) / 2 - 40;

            // 1. åˆ›å»ºé«˜æ¸…ç”»å¸ƒ
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = cW;
            tempCanvas.height = cH;
            const tCtx = tempCanvas.getContext('2d');
            
            // 2. ç»˜åˆ¶å½“å‰è§†é¢‘å¸§
            const vW = video.videoWidth;
            const vH = video.videoHeight;
            const scale = Math.max(cW / vW, cH / vH);
            const drawW = vW * scale;
            const drawH = vH * scale;
            const offsetX = (cW - drawW) / 2;
            const offsetY = (cH - drawH) / 2;
            tCtx.drawImage(video, offsetX, offsetY, drawW, drawH);

            // 3. æå–ç»¿æ¡†åŒºåŸŸ
            const cropData = tCtx.getImageData(boxX, boxY, boxW, boxH);

            // 4. ç”Ÿæˆæœ€ç»ˆå›¾ç‰‡
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = boxW;
            finalCanvas.height = boxH;
            const fCtx = finalCanvas.getContext('2d');
            fCtx.putImageData(cropData, 0, 0);

            // 5. é»‘ç™½å¤„ç†
            if (!isColor) {
                const imgData = fCtx.getImageData(0, 0, finalCanvas.width, finalCanvas.height);
                const data = imgData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                    const val = gray > 115 ? 255 : gray * 0.7; // å¯¹æ¯”åº¦å¢å¼º
                    data[i] = data[i+1] = data[i+2] = val;
                }
                fCtx.putImageData(imgData, 0, 0);
            }

            // 6. æ˜¾ç¤ºå¹¶å±…ä¸­
            const img = document.getElementById('img-' + currentSide);
            const ph = document.getElementById('ph-' + currentSide);
            img.src = finalCanvas.toDataURL('image/jpeg', 0.95);
            img.style.display = 'block';
            ph.style.display = 'none';

            closeCamera();
        }

        function closeCamera() {
            modal.style.display = 'none';
            cancelAnimationFrame(animationId);
            if (stream) {
                stream.getTracks().forEach(t => t.stop());
                stream = null;
            }
        }

        function makePDF() {
            const el = document.getElementById('pdf-area');
            if (!document.getElementById('img-front').src) { return alert("è¯·å…ˆæ‹æ‘„ç…§ç‰‡"); }
            el.classList.add('generating');
            html2pdf().set({ 
                margin: 0, 
                filename: 'èº«ä»½è¯å¤å°ä»¶.pdf', 
                image: { type: 'jpeg', quality: 0.98 }, 
                html2canvas: { scale: 2, useCORS: true, scrollY: 0 }, 
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' } 
            }).from(el).save().then(() => el.classList.remove('generating'));
        }
    </script>
</body>
</html>
