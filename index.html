<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¯ä»¶æ‰«æç»ˆæç‰ˆ(å½©è‰²/é»‘ç™½)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: manipulation; }
        body { 
            background: #e5e5e5; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; padding-bottom: 90px;
        }

        /* === A4 çº¸å¼ å®¹å™¨ === */
        .paper-container {
            background: white; width: 95vw; max-width: 500px; aspect-ratio: 210/297; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.1); display: flex; flex-direction: column; 
            justify-content: center; align-items: center; gap: 45px; padding: 0;
        }

        /* === å¡æ§½ (ç»å¯¹å±…ä¸­ä¿®å¤ç‰ˆ) === */
        .scan-slot {
            width: 85.6mm; height: 54mm; max-width: 90%; aspect-ratio: 85.6/54; 
            border: 2px dashed #ccc; background-color: #f9f9f9; border-radius: 4px; 
            position: relative; overflow: hidden; cursor: pointer; 
            display: flex; justify-content: center; align-items: center;
        }

        /* å›¾ç‰‡ç»å¯¹å±…ä¸­ï¼Œé˜²æ­¢åå·¦ */
        .scan-slot img { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; height: 100%; object-fit: fill; display: none; z-index: 2;
        }

        .slot-placeholder { text-align: center; color: #999; pointer-events: none; z-index: 1; }
        .slot-placeholder h3 { font-size: 16px; margin-bottom: 5px; }

        /* === åº•éƒ¨ä¸»æŒ‰é’® === */
        .bottom-bar {
            position: fixed; bottom: 0; left: 0; width: 100%; background: white; padding: 15px 20px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05); display: flex; gap: 15px; z-index: 50;
        }
        .btn { flex: 1; height: 50px; border-radius: 25px; border: none; font-size: 16px; font-weight: bold; cursor: pointer; }
        .btn-main { background: #2563eb; color: white; }
        .btn-sec { background: #f1f5f9; color: #333; }

        /* === ç›¸æœºç•Œé¢ === */
        .camera-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: black; z-index: 999; display: none; justify-content: center; align-items: center;
        }
        video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        .mask-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        /* é¡¶éƒ¨çŠ¶æ€æç¤º */
        .mode-status {
            position: absolute; top: 50px; width: 100%; text-align: center;
            color: #00ff00; font-size: 16px; font-weight: bold; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.9); z-index: 30; pointer-events: none;
        }

        .guide-text { position: absolute; top: 12%; width: 100%; text-align: center; color: white; font-size: 14px; text-shadow: 0 2px 4px rgba(0,0,0,0.8); z-index: 20; opacity: 0.8;}

        /* === ç›¸æœºæ“ä½œæ  === */
        .cam-actions { 
            position: absolute; bottom: 30px; width: 100%; 
            display: flex; flex-direction: column; align-items: center; gap: 20px; z-index: 50; 
        }

        /* æ‹ç…§é‚£ä¸€æ’ */
        .shutter-row {
            display: flex; width: 100%; justify-content: space-around; align-items: center;
        }

        .shutter-btn { width: 72px; height: 72px; background: white; border-radius: 50%; border: 5px solid rgba(220,220,220,0.5); cursor: pointer; }
        .shutter-btn:active { transform: scale(0.9); }
        
        .action-btn { 
            color: white; background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.3); 
            font-size: 14px; padding: 10px 20px; border-radius: 20px; backdrop-filter: blur(5px);
        }

        /* æ¨¡å¼åˆ‡æ¢æŒ‰é’® (æ–°) */
        .mode-toggle-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white; padding: 8px 20px; border-radius: 20px;
            font-size: 14px; border: 1px solid white; cursor: pointer;
            backdrop-filter: blur(4px); margin-bottom: 10px;
        }

        #debug-info { position: absolute; top: 10px; left: 10px; color: lime; font-size: 10px; z-index: 100; display: none; }
        
        .generating .scan-slot { border: none; background: white; }
        .generating .slot-placeholder { display: none; }
    </style>
</head>
<body>
    <div class="paper-container" id="pdf-area">
        <div class="scan-slot" onclick="initCamera('front')">
            <div class="slot-placeholder" id="ph-front"><h3>+ èº«ä»½è¯äººåƒé¢</h3><p>ç‚¹å‡»æ‹æ‘„</p></div>
            <img id="img-front">
        </div>
        <div class="scan-slot" onclick="initCamera('back')">
            <div class="slot-placeholder" id="ph-back"><h3>+ èº«ä»½è¯å›½å¾½é¢</h3><p>ç‚¹å‡»æ‹æ‘„</p></div>
            <img id="img-back">
        </div>
    </div>

    <div class="bottom-bar">
        <button class="btn btn-sec" onclick="location.reload()">é‡ç½®</button>
        <button class="btn btn-main" onclick="makePDF()">ç”Ÿæˆ PDF</button>
    </div>

    <div class="camera-overlay" id="cam-modal">
        <video id="video" autoplay playsinline muted></video>
        <div id="debug-info"></div>
        
        <div class="mode-status" id="status-text">å½“å‰æ¨¡å¼ï¼šğŸŒˆ å½©è‰²åŸå›¾</div>
        <div class="guide-text">è¯·å°†è¯ä»¶å¡«æ»¡ç»¿æ¡†</div>

        <svg class="mask-svg" width="100%" height="100%">
            <defs><mask id="mask-layer"><rect x="0" y="0" width="100%" height="100%" fill="white" /><rect id="cutout-rect" fill="black" rx="8" ry="8" /></mask></defs>
            <rect x="0" y="0" width="100%" height="100%" fill="rgba(0,0,0,0.9)" mask="url(#mask-layer)" />
            <rect id="border-rect" fill="transparent" stroke="#00ff00" stroke-width="2" rx="8" ry="8" />
        </svg>

        <div class="cam-actions">
            <button class="mode-toggle-btn" onclick="toggleColorMode()">åˆ‡æ¢ï¼šé»‘ç™½ / å½©è‰²</button>

            <div class="shutter-row">
                <button class="action-btn" onclick="closeCam()">å–æ¶ˆ</button>
                <button class="shutter-btn" onclick="takePhoto()"></button>
                <button class="action-btn" onclick="cycleCamera()">æ¢é•œå¤´</button>
            </div>
        </div>
    </div>

    <script>
        let currentStream = null;
        let currentSide = '';
        let videoDevices = [];
        let devIndex = 0;
        // é»˜è®¤ä¸º false (å³å½©è‰²æ¨¡å¼)ï¼Œè®©ç”¨æˆ·è‡ªå·±é€‰
        let isBlackAndWhite = false; 

        const video = document.getElementById('video');
        const modal = document.getElementById('cam-modal');
        const cutout = document.getElementById('cutout-rect');
        const border = document.getElementById('border-rect');
        const statusText = document.getElementById('status-text');
        const debug = document.getElementById('debug-info');

        // 1. åˆ‡æ¢è‰²å½©æ¨¡å¼
        function toggleColorMode() {
            isBlackAndWhite = !isBlackAndWhite;
            if (isBlackAndWhite) {
                statusText.innerText = "å½“å‰æ¨¡å¼ï¼šğŸ“„ é»‘ç™½å¤å°";
                statusText.style.color = "#ffffff";
            } else {
                statusText.innerText = "å½“å‰æ¨¡å¼ï¼šğŸŒˆ å½©è‰²åŸå›¾";
                statusText.style.color = "#00ff00";
            }
        }

        function getMaskRect() { 
            const sW = window.innerWidth; const sH = window.innerHeight; 
            const w = sW * 0.88; const h = w / 1.585; 
            const x = (sW - w) / 2; const y = (sH - h) / 2 - 50; 
            return { x, y, w, h }; 
        }

        function updateMaskOverlay() { 
            const rect = getMaskRect(); 
            cutout.setAttribute('x', rect.x); cutout.setAttribute('y', rect.y); 
            cutout.setAttribute('width', rect.w); cutout.setAttribute('height', rect.h); 
            border.setAttribute('x', rect.x); border.setAttribute('y', rect.y); 
            border.setAttribute('width', rect.w); border.setAttribute('height', rect.h); 
        }

        async function initCamera(side) { 
            currentSide = side; 
            updateMaskOverlay(); 
            modal.style.display = 'flex'; 
            
            // é»˜è®¤ä½¿ç”¨ç¯å¢ƒé•œå¤´(åç½®)
            await startStream({ video: { facingMode: "environment" } }); 
            await enumerateDevices(); 
        }

        async function startStream(constraints) { 
            if (currentStream) { currentStream.getTracks().forEach(t => t.stop()); } 
            try { 
                currentStream = await navigator.mediaDevices.getUserMedia({ audio: false, ...constraints }); 
                video.srcObject = currentStream; 
            } catch (err) { 
                console.error(err); alert("ç›¸æœºå¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™"); 
            } 
        }

        async function enumerateDevices() { 
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return; 
            const devs = await navigator.mediaDevices.enumerateDevices(); 
            videoDevices = devs.filter(d => d.kind === 'videoinput'); 
            if (currentStream && videoDevices.length > 0) { 
                const track = currentStream.getVideoTracks()[0]; 
                const idx = videoDevices.findIndex(d => d.deviceId === track.getSettings().deviceId); 
                if (idx !== -1) devIndex = idx; 
                debug.innerText = `Cam: ${devIndex}/${videoDevices.length}`;
            } 
        }

        async function cycleCamera() { 
            if (videoDevices.length < 2) { 
                await enumerateDevices(); 
                if (videoDevices.length < 2) return alert("åªæœ‰ä¸€ä¸ªæ‘„åƒå¤´");
            } 
            devIndex = (devIndex + 1) % videoDevices.length; 
            const nextDev = videoDevices[devIndex]; 
            await startStream({ video: { deviceId: { exact: nextDev.deviceId }, width: { ideal: 1920 }, height: { ideal: 1080 } } }); 
        }

        function takePhoto() { 
            if (!currentStream) return; 
            const canvas = document.createElement('canvas'); 
            const ctx = canvas.getContext('2d'); 
            
            const vW = video.videoWidth; const vH = video.videoHeight; 
            const rect = video.getBoundingClientRect(); 
            const sW = rect.width; const sH = rect.height; 
            
            const videoRatio = vW / vH; const screenRatio = sW / sH; 
            let renderW, renderH; 
            if (screenRatio > videoRatio) { renderW = sW; renderH = sW / videoRatio; } 
            else { renderH = sH; renderW = sH * videoRatio; } 
            
            const mask = getMaskRect(); 
            const offsetX = (renderW - sW) / 2; 
            const offsetY = (renderH - sH) / 2; 
            
            const maskX = mask.x + offsetX; 
            const maskY = mask.y + offsetY; 
            const scale = vW / renderW; 
            
            canvas.width = 1000; canvas.height = 1000 / 1.585; 
            
            ctx.drawImage(video, maskX * scale, maskY * scale, mask.w * scale, mask.h * scale, 0, 0, canvas.width, canvas.height); 

            // å¤„ç†é»‘ç™½æ¨¡å¼
            if (isBlackAndWhite) { 
                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height); 
                const data = imgData.data; 
                for (let i = 0; i < data.length; i += 4) { 
                    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]; 
                    const val = gray > 110 ? 255 : gray * 0.7; 
                    data[i] = data[i+1] = data[i+2] = val; 
                } 
                ctx.putImageData(imgData, 0, 0); 
            } 
            
            const img = document.getElementById('img-' + currentSide); 
            const ph = document.getElementById('ph-' + currentSide); 
            img.src = canvas.toDataURL('image/jpeg', 0.95); 
            img.style.display = 'block'; 
            ph.style.display = 'none'; 
            closeCam(); 
        }

        function closeCam() { modal.style.display = 'none'; if(currentStream) currentStream.getTracks().forEach(t=>t.stop()); }

        function makePDF() { 
            const el = document.getElementById('pdf-area'); 
            if (!document.getElementById('img-front').src) { alert("è¯·å…ˆæ‹æ‘„"); return; } 
            el.classList.add('generating'); 
            html2pdf().set({ margin: 0, filename: 'èº«ä»½è¯å¤å°ä»¶.pdf', image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 2, useCORS: true, scrollY: 0 }, jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' } }).from(el).save().then(() => el.classList.remove('generating')); 
        }
        
        window.onresize = updateMaskOverlay;
    </script>
</body>
</html>
